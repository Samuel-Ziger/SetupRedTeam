#!/bin/bash

################################################################################
# SCRIPT DE RETESTE - adivisao.com.br
# Data: 28/11/2025
# Analista: Samuel Ziger
# Objetivo: Validar correÃ§Ã£o de vulnerabilidades crÃ­ticas e altas
################################################################################

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Solicitar informaÃ§Ãµes do alvo
echo -e "${BLUE}=================================${NC}"
echo -e "${BLUE}SCRIPT DE RETESTE - Pentesting${NC}"
echo -e "${BLUE}=================================${NC}\n"

read -p "Digite o domÃ­nio alvo (ex: exemplo.com.br): " TARGET
read -p "Digite o IP do alvo (opcional, pressione Enter para pular): " TARGET_IP

if [ -z "$TARGET" ]; then
    echo -e "${RED}[ERRO] DomÃ­nio Ã© obrigatÃ³rio!${NC}"
    exit 1
fi

echo -e "\n${GREEN}Alvo configurado: $TARGET${NC}"
[ ! -z "$TARGET_IP" ] && echo -e "${GREEN}IP: $TARGET_IP${NC}"
echo ""

# ConfiguraÃ§Ãµes
OUTPUT_DIR="./resultados_${TARGET//./_}_$(date +%Y%m%d_%H%M%S)"
mkdir -p "$OUTPUT_DIR"

# Log de execuÃ§Ã£o
LOG_FILE="$OUTPUT_DIR/execution.log"
exec > >(tee -a "$LOG_FILE") 2>&1

echo -e "${BLUE}=================================${NC}"
echo -e "${BLUE}RETESTE: $TARGET${NC}"
echo -e "${BLUE}Data: $(date)${NC}"
echo -e "${BLUE}=================================${NC}\n"

################################################################################
# FUNÃ‡ÃƒO: Banner de seÃ§Ã£o
################################################################################
print_section() {
    echo -e "\n${GREEN}[$(date +%H:%M:%S)] ========== $1 ==========${NC}\n"
}

################################################################################
# FUNÃ‡ÃƒO: Verificar se comando existe
################################################################################
check_tool() {
    if ! command -v $1 &> /dev/null; then
        echo -e "${RED}[ERRO] $1 nÃ£o encontrado. Instale com: sudo apt install $2${NC}"
        return 1
    else
        echo -e "${GREEN}[OK] $1 encontrado${NC}"
        return 0
    fi
}

################################################################################
# PRÃ‰-REQUISITOS: Verificar ferramentas instaladas
################################################################################
print_section "Verificando Ferramentas"

check_tool "curl" "curl" || exit 1
check_tool "nmap" "nmap" || exit 1
check_tool "openssl" "openssl" || exit 1
check_tool "jq" "jq" || exit 1
check_tool "python3" "python3" || exit 1
check_tool "gobuster" "gobuster" || exit 1

echo -e "\n${GREEN}Todas as ferramentas necessÃ¡rias estÃ£o instaladas!${NC}\n"

################################################################################
# TESTE 1.1: ExposiÃ§Ã£o de Tokens JWT e API Keys (CRÃTICO)
################################################################################
print_section "TESTE 1.1: Verificando ExposiÃ§Ã£o de Tokens"

echo "# Procurando por tokens/keys no HTML/JS principal..."
curl -s "https://${TARGET}/" -L > "$OUTPUT_DIR/homepage.html"

echo "## Buscando padrÃµes de JWT (eyJhbGci)..."
grep -i "eyJhbGci" "$OUTPUT_DIR/homepage.html" > "$OUTPUT_DIR/1.1_jwt_tokens.txt"
if [ -s "$OUTPUT_DIR/1.1_jwt_tokens.txt" ]; then
    echo -e "${RED}[REPROVADO] Tokens JWT encontrados no frontend!${NC}"
    cat "$OUTPUT_DIR/1.1_jwt_tokens.txt"
else
    echo -e "${GREEN}[APROVADO] Nenhum JWT encontrado no HTML principal${NC}"
fi

echo -e "\n## Buscando por 'apikey', 'bearer', 'authorization'..."
grep -iE "apikey|bearer|authorization.*:.*ey" "$OUTPUT_DIR/homepage.html" > "$OUTPUT_DIR/1.1_api_keys.txt"
if [ -s "$OUTPUT_DIR/1.1_api_keys.txt" ]; then
    echo -e "${RED}[REPROVADO] PossÃ­veis API keys encontradas!${NC}"
    cat "$OUTPUT_DIR/1.1_api_keys.txt"
else
    echo -e "${GREEN}[APROVADO] Nenhuma API key visÃ­vel no HTML${NC}"
fi

# Extrair e analisar scripts JS
echo -e "\n## Extraindo URLs de scripts JS..."
grep -oP 'src="[^"]*\.js[^"]*"' "$OUTPUT_DIR/homepage.html" | cut -d'"' -f2 | head -10 > "$OUTPUT_DIR/1.1_js_files.txt"

echo "Scripts encontrados:"
cat "$OUTPUT_DIR/1.1_js_files.txt"

echo -e "\n## Analisando primeiros 5 arquivos JS em busca de tokens..."
head -5 "$OUTPUT_DIR/1.1_js_files.txt" | while read jsurl; do
    # Converter URL relativa em absoluta
    if [[ $jsurl == http* ]]; then
        full_url="$jsurl"
    else
        full_url="https://${TARGET}${jsurl}"
    fi
    
    echo "Analisando: $full_url"
    curl -s "$full_url" 2>/dev/null | grep -iE "eyJhbGci|apikey.*:|authorization.*:" > "$OUTPUT_DIR/1.1_js_$(basename $jsurl).txt"
    
    if [ -s "$OUTPUT_DIR/1.1_js_$(basename $jsurl).txt" ]; then
        echo -e "${RED}  â””â”€ [!] PossÃ­vel token encontrado!${NC}"
        head -3 "$OUTPUT_DIR/1.1_js_$(basename $jsurl).txt"
    else
        echo -e "${GREEN}  â””â”€ [OK] Nenhum token encontrado${NC}"
    fi
done

################################################################################
# TESTE 1.2: Endpoint /fileupload AcessÃ­vel (CRÃTICO - RCE)
################################################################################
print_section "TESTE 1.2: Verificando Endpoint /fileupload"

echo "# Testando acesso ao endpoint..."
curl -I "https://${TARGET}/fileupload" 2>&1 | tee "$OUTPUT_DIR/1.2_fileupload_head.txt"

STATUS=$(curl -I -s "https://${TARGET}/fileupload" 2>&1 | grep "HTTP" | awk '{print $2}' | head -1)

if [[ "$STATUS" == "200" || "$STATUS" == "301" || "$STATUS" == "302" ]]; then
    echo -e "${RED}[REPROVADO] Endpoint /fileupload estÃ¡ acessÃ­vel (Status: $STATUS)${NC}"
    
    echo -e "\n## Testando POST sem autenticaÃ§Ã£o..."
    echo "test file content" > /tmp/test.txt
    curl -X POST "https://${TARGET}/fileupload" \
        -F "file=@/tmp/test.txt" \
        -v 2>&1 | tee "$OUTPUT_DIR/1.2_fileupload_post.txt"
    
    POST_STATUS=$(grep "< HTTP" "$OUTPUT_DIR/1.2_fileupload_post.txt" | tail -1 | awk '{print $3}')
    
    if [[ "$POST_STATUS" == "200" || "$POST_STATUS" == "201" ]]; then
        echo -e "${RED}[CRÃTICO] Upload funcionou sem autenticaÃ§Ã£o!${NC}"
    elif [[ "$POST_STATUS" == "401" || "$POST_STATUS" == "403" ]]; then
        echo -e "${YELLOW}[PARCIAL] Upload bloqueado por autenticaÃ§Ã£o (Status: $POST_STATUS)${NC}"
    fi
    
    rm -f /tmp/test.txt
    
elif [[ "$STATUS" == "401" || "$STATUS" == "403" ]]; then
    echo -e "${YELLOW}[PARCIAL] Endpoint existe mas requer autenticaÃ§Ã£o (Status: $STATUS)${NC}"
elif [[ "$STATUS" == "404" ]]; then
    echo -e "${GREEN}[APROVADO] Endpoint nÃ£o encontrado (Status: 404)${NC}"
else
    echo -e "${YELLOW}[INDEFINIDO] Status inesperado: $STATUS${NC}"
fi

################################################################################
# TESTE 1.3: EnumeraÃ§Ã£o de UsuÃ¡rios via /elasticsearch/msearch (ALTO)
################################################################################
print_section "TESTE 1.3: Verificando EnumeraÃ§Ã£o de UsuÃ¡rios (Elasticsearch)"

echo "# Testando acesso ao endpoint Elasticsearch..."
curl -s "https://${TARGET}/elasticsearch/msearch" \
    -H "Content-Type: application/json" \
    -d '{"query":{"match_all":{}}}' \
    2>&1 | tee "$OUTPUT_DIR/1.3_elasticsearch_test1.txt" | jq . 2>/dev/null || cat "$OUTPUT_DIR/1.3_elasticsearch_test1.txt"

echo -e "\n## Testando com formato NDJSON..."
printf '{"index":"*"}\n{"query":{"match_all":{}},"size":10}\n' | \
    curl -s "https://${TARGET}/elasticsearch/msearch" \
    -X POST \
    -H "Content-Type: application/x-ndjson" \
    --data-binary @- \
    2>&1 | tee "$OUTPUT_DIR/1.3_elasticsearch_ndjson.txt"

echo -e "\n## Procurando por emails expostos..."
grep -i "email" "$OUTPUT_DIR/1.3_elasticsearch_ndjson.txt" > "$OUTPUT_DIR/1.3_emails_found.txt"

if [ -s "$OUTPUT_DIR/1.3_emails_found.txt" ]; then
    echo -e "${RED}[REPROVADO] Emails encontrados na resposta!${NC}"
    cat "$OUTPUT_DIR/1.3_emails_found.txt"
else
    echo -e "${GREEN}[APROVADO] Nenhum email encontrado na resposta${NC}"
fi

echo -e "\n## Procurando por flags de usuÃ¡rio (user_signed_up, etc)..."
grep -iE "user_signed_up|user_exists|is_registered" "$OUTPUT_DIR/1.3_elasticsearch_ndjson.txt" > "$OUTPUT_DIR/1.3_user_flags.txt"

if [ -s "$OUTPUT_DIR/1.3_user_flags.txt" ]; then
    echo -e "${RED}[REPROVADO] Flags de enumeraÃ§Ã£o encontradas!${NC}"
    cat "$OUTPUT_DIR/1.3_user_flags.txt"
else
    echo -e "${GREEN}[APROVADO] Nenhuma flag de enumeraÃ§Ã£o encontrada${NC}"
fi

################################################################################
# TESTE 1.4: Portas Administrativas Expostas (ALTO)
################################################################################
print_section "TESTE 1.4: Verificando Portas Administrativas"

PORTAS="2052,2053,2082,2083,2086,2087,2095,2096,8080,8443"

echo "# Executando Nmap nas portas reportadas..."
nmap -sV -p "$PORTAS" "$TARGET" -oN "$OUTPUT_DIR/1.4_nmap_portas.txt"

echo -e "\n## Resultado do scan:"
cat "$OUTPUT_DIR/1.4_nmap_portas.txt"

echo -e "\n## Testando conectividade HTTP em cada porta..."
for port in 2052 2053 2082 2083 2086 2087 2095 2096 8080 8443; do
    echo -e "\n=== Testando porta $port ==="
    timeout 5 curl -I -m 3 --connect-timeout 3 "https://${TARGET}:${port}/" 2>&1 | head -10 | tee "$OUTPUT_DIR/1.4_porta_${port}.txt"
    
    # Verificar se conectou
    if grep -q "HTTP" "$OUTPUT_DIR/1.4_porta_${port}.txt"; then
        echo -e "${RED}[ALERTA] Porta $port respondeu HTTP!${NC}"
    elif grep -q "Connection refused\|Connection timed out" "$OUTPUT_DIR/1.4_porta_${port}.txt"; then
        echo -e "${GREEN}[OK] Porta $port bloqueada/fechada${NC}"
    fi
done

echo -e "\n## Resumo:"
PORTAS_ABERTAS=$(grep -l "HTTP" "$OUTPUT_DIR"/1.4_porta_*.txt | wc -l)
if [ "$PORTAS_ABERTAS" -eq 0 ]; then
    echo -e "${GREEN}[APROVADO] Nenhuma porta administrativa acessÃ­vel${NC}"
else
    echo -e "${RED}[REPROVADO] $PORTAS_ABERTAS porta(s) administrativa(s) acessÃ­vel(is)${NC}"
fi

################################################################################
# TESTE 1.5: Protocolos TLS Obsoletos (ALTO)
################################################################################
print_section "TESTE 1.5: Verificando Protocolos TLS"

echo "# Testando TLS 1.0..."
timeout 10 openssl s_client -connect "${TARGET}:443" -tls1 2>&1 | tee "$OUTPUT_DIR/1.5_tls10.txt" | grep -i "protocol\|alert\|error"

if grep -qi "alert\|error\|handshake failure" "$OUTPUT_DIR/1.5_tls10.txt"; then
    echo -e "${GREEN}[APROVADO] TLS 1.0 desabilitado${NC}"
else
    echo -e "${RED}[REPROVADO] TLS 1.0 ainda ativo!${NC}"
fi

echo -e "\n# Testando TLS 1.1..."
timeout 10 openssl s_client -connect "${TARGET}:443" -tls1_1 2>&1 | tee "$OUTPUT_DIR/1.5_tls11.txt" | grep -i "protocol\|alert\|error"

if grep -qi "alert\|error\|handshake failure" "$OUTPUT_DIR/1.5_tls11.txt"; then
    echo -e "${GREEN}[APROVADO] TLS 1.1 desabilitado${NC}"
else
    echo -e "${RED}[REPROVADO] TLS 1.1 ainda ativo!${NC}"
fi

echo -e "\n# Testando TLS 1.2..."
timeout 10 openssl s_client -connect "${TARGET}:443" -tls1_2 2>&1 | tee "$OUTPUT_DIR/1.5_tls12.txt" | grep -i "protocol"

if grep -qi "TLSv1.2" "$OUTPUT_DIR/1.5_tls12.txt"; then
    echo -e "${GREEN}[OK] TLS 1.2 ativo e funcional${NC}"
else
    echo -e "${YELLOW}[ALERTA] TLS 1.2 pode estar desabilitado${NC}"
fi

echo -e "\n# Testando TLS 1.3..."
timeout 10 openssl s_client -connect "${TARGET}:443" -tls1_3 2>&1 | tee "$OUTPUT_DIR/1.5_tls13.txt" | grep -i "protocol"

if grep -qi "TLSv1.3" "$OUTPUT_DIR/1.5_tls13.txt"; then
    echo -e "${GREEN}[OK] TLS 1.3 ativo e funcional${NC}"
else
    echo -e "${YELLOW}[INFO] TLS 1.3 nÃ£o suportado (opcional)${NC}"
fi

################################################################################
# TESTE 1.6: Cookie sem HttpOnly/Secure/SameSite (MÃ‰DIO)
################################################################################
print_section "TESTE 1.6: Verificando Flags de Cookies"

echo "# Capturando cookies da homepage..."
curl -I "https://${TARGET}/" 2>&1 | tee "$OUTPUT_DIR/1.6_cookies_homepage.txt" | grep -i "set-cookie"

echo -e "\n## Analisando flags de seguranÃ§a..."
grep -i "set-cookie" "$OUTPUT_DIR/1.6_cookies_homepage.txt" > "$OUTPUT_DIR/1.6_cookies_only.txt"

if [ -s "$OUTPUT_DIR/1.6_cookies_only.txt" ]; then
    while IFS= read -r cookie_line; do
        echo -e "\nCookie: $cookie_line"
        
        # Verificar HttpOnly
        if echo "$cookie_line" | grep -qi "httponly"; then
            echo -e "${GREEN}  âœ“ HttpOnly presente${NC}"
        else
            echo -e "${RED}  âœ— HttpOnly AUSENTE${NC}"
        fi
        
        # Verificar Secure
        if echo "$cookie_line" | grep -qi "secure"; then
            echo -e "${GREEN}  âœ“ Secure presente${NC}"
        else
            echo -e "${RED}  âœ— Secure AUSENTE${NC}"
        fi
        
        # Verificar SameSite
        if echo "$cookie_line" | grep -qi "samesite"; then
            SAMESITE=$(echo "$cookie_line" | grep -oP "samesite=\K\w+" -i)
            echo -e "${GREEN}  âœ“ SameSite=$SAMESITE${NC}"
        else
            echo -e "${RED}  âœ— SameSite AUSENTE${NC}"
        fi
    done < "$OUTPUT_DIR/1.6_cookies_only.txt"
else
    echo -e "${BLUE}[INFO] Nenhum cookie Set-Cookie encontrado na homepage${NC}"
fi

################################################################################
# TESTE 1.7: CORS Inconsistente (MÃ‰DIO)
################################################################################
print_section "TESTE 1.7: Verificando ConfiguraÃ§Ã£o CORS"

echo "# Testando CORS com origem maliciosa..."
curl -H "Origin: https://malicious.com" \
    -H "Access-Control-Request-Method: POST" \
    -H "Access-Control-Request-Headers: X-Requested-With" \
    -X OPTIONS \
    "https://${TARGET}/" -v 2>&1 | tee "$OUTPUT_DIR/1.7_cors_test.txt" | grep -i "access-control"

echo -e "\n## Verificando header Access-Control-Allow-Origin..."
curl -I "https://${TARGET}/" 2>&1 | grep -i "access-control-allow-origin" > "$OUTPUT_DIR/1.7_acao.txt"

if grep -q "Access-Control-Allow-Origin: \*" "$OUTPUT_DIR/1.7_acao.txt"; then
    echo -e "${RED}[REPROVADO] CORS permite qualquer origem (*)${NC}"
elif grep -qi "access-control-allow-origin" "$OUTPUT_DIR/1.7_acao.txt"; then
    ORIGIN=$(grep -i "access-control-allow-origin" "$OUTPUT_DIR/1.7_acao.txt")
    echo -e "${GREEN}[APROVADO] CORS configurado: $ORIGIN${NC}"
else
    echo -e "${BLUE}[INFO] Nenhum header ACAO encontrado${NC}"
fi

################################################################################
# TESTE 1.8: CSP em Report-Only (MÃ‰DIO)
################################################################################
print_section "TESTE 1.8: Verificando Content Security Policy"

echo "# Capturando headers CSP..."
curl -I "https://${TARGET}/" 2>&1 | tee "$OUTPUT_DIR/1.8_csp.txt" | grep -i "content-security-policy"

if grep -qi "content-security-policy-report-only" "$OUTPUT_DIR/1.8_csp.txt"; then
    echo -e "${RED}[REPROVADO] CSP estÃ¡ em modo Report-Only (nÃ£o protege)${NC}"
    grep -i "content-security-policy-report-only" "$OUTPUT_DIR/1.8_csp.txt"
elif grep -qi "content-security-policy:" "$OUTPUT_DIR/1.8_csp.txt"; then
    echo -e "${GREEN}[APROVADO] CSP ativo (enforce mode)${NC}"
    grep -i "content-security-policy:" "$OUTPUT_DIR/1.8_csp.txt"
else
    echo -e "${YELLOW}[ALERTA] Nenhum CSP encontrado${NC}"
fi

################################################################################
# TESTE 1.9: Headers de Tecnologia Expostos (MÃ‰DIO)
################################################################################
print_section "TESTE 1.9: Verificando Headers de Tecnologia"

echo "# Buscando headers sensÃ­veis..."
curl -I "https://${TARGET}/" 2>&1 | tee "$OUTPUT_DIR/1.9_headers.txt" | grep -iE "x-powered-by|x-bubble|sb-project|server:"

echo -e "\n## AnÃ¡lise:"

if grep -qi "x-powered-by" "$OUTPUT_DIR/1.9_headers.txt"; then
    echo -e "${RED}[REPROVADO] X-Powered-By exposto: $(grep -i x-powered-by $OUTPUT_DIR/1.9_headers.txt)${NC}"
else
    echo -e "${GREEN}[APROVADO] X-Powered-By removido${NC}"
fi

if grep -qi "x-bubble" "$OUTPUT_DIR/1.9_headers.txt"; then
    echo -e "${RED}[REPROVADO] Headers Bubble.io expostos${NC}"
else
    echo -e "${GREEN}[APROVADO] Headers Bubble.io removidos${NC}"
fi

if grep -qi "sb-project" "$OUTPUT_DIR/1.9_headers.txt"; then
    echo -e "${RED}[REPROVADO] Header Supabase project-ref exposto${NC}"
else
    echo -e "${GREEN}[APROVADO] Header Supabase removido${NC}"
fi

################################################################################
# TESTE 1.10: Rate Limiting Parcial (MÃ‰DIO)
################################################################################
print_section "TESTE 1.10: Verificando Rate Limiting"

echo "# Criando script Python para teste de rate limit..."
cat > "$OUTPUT_DIR/test_rate_limit.py" << 'PYEOF'
import requests
import time
import sys

url = "https://adivisao.com.br/auth/v1/token?grant_type=password"
blocked = False

print("Testando rate limit no endpoint de login...")
print(f"URL: {url}\n")

for i in range(15):
    try:
        r = requests.post(url, json={"email":"test@test.com","password":"wrong"}, timeout=5)
        status = r.status_code
        print(f"Tentativa {i+1:2d}: Status {status}", end="")
        
        if status == 429:
            print(" â† RATE LIMITED!")
            blocked = True
            break
        elif status == 401:
            print(" (Credenciais invÃ¡lidas - esperado)")
        else:
            print()
            
        time.sleep(0.3)
    except Exception as e:
        print(f"Tentativa {i+1:2d}: ERRO - {str(e)}")
        
if blocked:
    print("\nâœ… [APROVADO] Rate limiting ativo!")
    sys.exit(0)
else:
    print("\nâŒ [REPROVADO] Nenhum rate limiting detectado apÃ³s 15 tentativas")
    sys.exit(1)
PYEOF

echo "# Executando teste..."
python3 "$OUTPUT_DIR/test_rate_limit.py" | tee "$OUTPUT_DIR/1.10_rate_limit_result.txt"

################################################################################
# RELATÃ“RIO FINAL
################################################################################
print_section "RELATÃ“RIO CONSOLIDADO"

echo "# Gerando resumo dos testes..."

cat > "$OUTPUT_DIR/RELATORIO_RESUMO.md" << EOF
# RelatÃ³rio de Reteste - $TARGET
**Data:** $(date)
**Analista:** Samuel Ziger
**DomÃ­nio:** $TARGET
**IP:** ${TARGET_IP:-N/A}

## Resumo Executivo

| # | Vulnerabilidade | Severidade | Status | ObservaÃ§Ãµes |
|---|-----------------|------------|--------|-------------|
| 1.1 | ExposiÃ§Ã£o de Tokens JWT/API Keys | ðŸ”´ CRÃTICO | [ ] | Ver 1.1_*.txt |
| 1.2 | Endpoint /fileupload AcessÃ­vel | ðŸ”´ CRÃTICO | [ ] | Ver 1.2_*.txt |
| 1.3 | EnumeraÃ§Ã£o de UsuÃ¡rios (Elasticsearch) | ðŸŸ  ALTO | [ ] | Ver 1.3_*.txt |
| 1.4 | Portas Administrativas Expostas | ðŸŸ  ALTO | [ ] | Ver 1.4_*.txt |
| 1.5 | Protocolos TLS Obsoletos | ðŸŸ  ALTO | [ ] | Ver 1.5_*.txt |
| 1.6 | Cookies sem Flags de SeguranÃ§a | ðŸ”µ MÃ‰DIO | [ ] | Ver 1.6_*.txt |
| 1.7 | CORS Inconsistente | ðŸ”µ MÃ‰DIO | [ ] | Ver 1.7_*.txt |
| 1.8 | CSP em Report-Only | ðŸ”µ MÃ‰DIO | [ ] | Ver 1.8_*.txt |
| 1.9 | Headers de Tecnologia Expostos | ðŸ”µ MÃ‰DIO | [ ] | Ver 1.9_*.txt |
| 1.10 | Rate Limiting Parcial | ðŸ”µ MÃ‰DIO | [ ] | Ver 1.10_*.txt |

## Arquivos de EvidÃªncia

Todos os outputs foram salvos em: \`$OUTPUT_DIR/\`

## PrÃ³ximos Passos

1. Revisar manualmente todos os arquivos .txt gerados
2. Preencher a coluna "Status" da tabela acima
3. Gerar relatÃ³rio executivo para o cliente
4. Agendar correÃ§Ãµes para vulnerabilidades nÃ£o resolvidas

EOF

cat "$OUTPUT_DIR/RELATORIO_RESUMO.md"

echo -e "\n${GREEN}=================================${NC}"
echo -e "${GREEN}RETESTE CONCLUÃDO!${NC}"
echo -e "${GREEN}=================================${NC}"
echo -e "\nResultados salvos em: ${BLUE}$OUTPUT_DIR${NC}"
echo -e "RelatÃ³rio resumido: ${BLUE}$OUTPUT_DIR/RELATORIO_RESUMO.md${NC}"
echo -e "Log de execuÃ§Ã£o: ${BLUE}$LOG_FILE${NC}\n"
